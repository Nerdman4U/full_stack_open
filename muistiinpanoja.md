Muistiinpanoja materiaalista

= Osa 2 =

Object spread
  foo = { ...bar, yyy:123 }

One of the arguments which setState accepts is an updater function: setState((prevState) => {}).

Efekti suoritetaan heti komponentin renderöinnin jälkeen.

Reactin tilaa ei saa muuttaa suoraan!

= Osa 1 =

JavaScriptissa this:in arvo siis määräytyy siitä, miten metodia on kutsuttu. 
- viittaus olioon katoaa (muuttuu globaaliksi objektiksi) jos olion metodi on kopioitu referenssiksi ja kutsutaan tämän metodin kautta.

BIND

JavaScriptissä ei ole muita tyyppejä kuin Boolean, Null, Undefined, Number, String, Symbol, BigInt ja Object.

Reactissa ei kuitenkaan ole sallittua muuttaa tilaa suoraan. Vie kopio.

Chromen developer-konsolin debuggeriin kirjoittamalla omassa tekstieditorissasi olevaan lähdekoodiin mihin tahansa kohtaan koodia komennon debugger.

Hookeja siis kuuluu kutsua ainoastaan React-komponentin määrittelevän funktion rungosta.

= Linkkejä =

== Kursseja ==
https://egghead.io/courses/understand-javascript-s-this-keyword-in-depth

https://egghead.io/courses/start-learning-react

https://egghead.io/courses/the-beginner-s-guide-to-reactjs


== Tutoriaaleja ==
https://developer.chrome.com/docs/devtools/overview/

== Muita ==

An IIFE (Immediately Invoked Function Expression)

In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. Blocks don't create scopes for var.

https://medium.com/@falsecrypt/solid-design-principles-for-javascript-single-responsibility-1-ca3b153ec28e

    The Single Responsibility Principle states that every component, class or function should have a well-defined, single responsibility and only one reason to change. 


